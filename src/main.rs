use crate::calculator::{Calculator, Op};
use std::io;
use std::io::Write;
use std::process::exit;
use rug::{Assign, Float};

mod calculator;

fn process(calc: &mut Calculator, inp: &str) {
    match inp {
        "q" => exit(0),
        "r" => { calc.drop(); return; }
        "d" => { calc.dup(); return; }
        "s" => { calc.swap(); return; }
        "z" => {
            let mut pi = Float::new(1024);
            pi.assign(Float::parse("3.1415926535897932384626433832795028841971693993751058209749\
                44592307816406286208998628034825342117067982148086513282306647093844609550582231725359408128\
                48111745028410270193852110555964462294895493038196442881097566593344612847564823378678316527\
                12019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628\
                29254091715364367892590360011330530548820466521384146951941511609433057270365759591953092186\
                11738193261179310511854807446237996274956735188575272489122793818301194912983367336244065664\
                30860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271\
                45263560827785771342757789609173637178721468440901224953430146549585371050792279689258923542\
                01995611212902196086403441815981362977477130996051870721134999999837297804995105973173281609\
                63185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206\
                17177669147303598253490428755468731159562863882353787593751957781857780532171226806613001927\
                87661119590921642019893809525720106548586327886593615338182796823030195203530185296899577362\
                25994138912497217752834791315155748572424541506959508295331168617278558890750983817546374649\
                39319255060400927701671139009848824012858361603563707660104710181942955596198946767837449448\
                25537977472684710404753464620804668425906949129331367702898915210475216205696602405803815019\
                35112533824300355876402474964732639141992726042699227967823547816360093417216412199245863150\
                30286182974555706749838505494588586926995690927210797509302955321165344987202755960236480665\
                49911988183479775356636980742654252786255181841757467289097777279380008164706001614524919217\
                32172147723501414419735685481613611573525521334757418494684385233239073941433345477624168625\
                18983569485562099219222184272550254256887671790494601653466804988627232791786085784383827967\
                97668145410095388378636095068006422512520511739298489608412848862694560424196528502221066118\
                63067442786220391949450471237137869609563643719172874677646575739624138908658326459958133904\
                780275900".replace(" ", "")).expect("wat"));
            calc.push(pi.as_complex().clone());
            return;
        }
        "e" => {
            let mut e = Float::new(1024);
            e.assign(Float::parse("2.7182818284590452353602874713526624977572470936999595749669\
                67627724076630353547594571382178525166427427466391932003059921817413596629043572900334295260\
                59563073813232862794349076323382988075319525101901157383418793070215408914993488416750924476\
                14606680822648001684774118537423454424371075390777449920695517027618386062613313845830007520\
                44933826560297606737113200709328709127443747047230696977209310141692836819025515108657463772\
                11125238978442505695369677078544996996794686445490598793163688923009879312773617821542499922\
                95763514822082698951936680331825288693984964651058209392398294887933203625094431173012381970\
                68416140397019837679320683282376464804295311802328782509819455815301756717361332069811250996\
                18188159304169035159888851934580727386673858942287922849989208680582574927961048419844436346\
                32449684875602336248270419786232090021609902353043699418491463140934317381436405462531520961\
                83690888707016768396424378140592714563549061303107208510383750510115747704171898610687396965\
                52126715468895703503540212340784981933432106817012100562788023519303322474501585390473041995\
                77770935036604169973297250886876966403555707162268447162560798826517871341951246652010305921\
                23667719432527867539855894489697096409754591856956380236370162112047742722836489613422516445\
                07818244235294863637214174023889344124796357437026375529444833799801612549227850925778256209\
                26226483262779333865664816277251640191059004916449982893150566047258027786318641551956532442\
                58698294695930801915298721172556347546396447910145904090586298496791287406870504895858671747\
                98546677575732056812884592054133405392200011378630094556068816674001698420558040336379537645\
                20304024322566135278369511778838638744396625322498506549958862342818997077332761717839280349\
                46501434558897071942586398772754710962953741521115136835062752602326484728703920764310059584\
                11661205452970302364725492966693811513732275364509888903136020572481765851180630364428123149\
                65507047510254465011727211555194866850800368532281831521960037356252794495158284188294787610\
                8526398139".replace(" ", "")).expect("wat"));
            calc.push(e.as_complex().clone());
            return;
        }
        "i" => {
            let mut float = Float::new(1024);
            float -= 1;
            let mut i = float.as_complex().clone();
            i.sqrt_mut();
            calc.push(i.clone());
            return;
        }
        _ => {}
    }

    let op = match inp {
        "+" => Option::Some(Op::ADD),
        "-" => Option::Some(Op::SUBTRACT),
        "*" => Option::Some(Op::MULTIPLY),
        "/" => Option::Some(Op::DIVIDE),
        "^" => Option::Some(Op::EXP),
        "a" => Option::Some(Op::SIN),
        "c" => Option::Some(Op::COS),
        "t" => Option::Some(Op::TAN),
        "n" => Option::Some(Op::COT),
        "S" => Option::Some(Op::ASIN),
        "C" => Option::Some(Op::ACOS),
        "T" => Option::Some(Op::ATAN),
        "l" => Option::Some(Op::SEC),
        "k" => Option::Some(Op::CSC),
        _ => Option::None
    };

    if op.is_some() {
        let o = op.unwrap();
        calc.op(o);
    } else {
        let parsed = Float::parse(inp);
        if parsed.is_err() {
            return;
        }
        let res = parsed.expect("wtf");
        let mut num = Float::new(1024);  // TODO
        num.assign(res);
        calc.push(num.as_complex().clone());
    }
}

fn main() {
    let mut calc = Calculator::new();
    let stdin = io::stdin();
    loop {
        print!("{esc}[2J{esc}[1;1H", esc = 27 as char);
        calc.print();
        print!("> ");
        io::stdout().flush().expect("failed to flush?");
        let mut inp = String::new();
        stdin.read_line(&mut inp).expect("what");
        inp = inp.replace("\n", "").replace("pi", "z");
        for rep in vec!["pi z", "sin a", "cos c", "tan t", "cot n", "asin S", "cot C", "atan T", "sec l", "csc k"] {
            let split = rep.split_once(' ').expect("wat");
            inp = inp.replace(split.0, split.1);
        }
        let mut last = String::new();
        let mut last_was_num = false;
        let mut last_was_space = true;
        for c in inp.chars() {
            if "0123456789.".contains(c) || (c == '-' && last_was_space) {
                last_was_num = true;
                last.push(c);
            } else {
                if last_was_num {
                    process(&mut calc, last.as_str());
                    last.clear();
                }
                if !c.is_whitespace() {
                    last.push(c);
                }
                if !last.is_empty() {
                    process(&mut calc, last.as_str());
                }
                last_was_num = false;
                last.clear();
            }
            last_was_space = c.is_whitespace();
        }
        if !last.is_empty() {
            process(&mut calc, last.as_str());
        }
    }
}
